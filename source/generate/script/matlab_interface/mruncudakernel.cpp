#include "mruncudakernel.h"

MRunCudaKernel::MRunCudaKernel(const std::string& name) : MRunBase(name)
{
}

void MRunCudaKernel::Make(std::ofstream &out) const
{
    const size_t num_inps = _modelMgr->Model(ds::INP)->NumPars(),
            num_ics = _modelMgr->Model(ds::INIT)->NumPars();
    const std::string num_model_pars = std::to_string(num_inps+num_ics);

    WriteHeader(out);
    out <<
            "%Auto-generated by DynaSys version " + ds::VERSION_STR + "\n"
            "%Set par_mat = [] to run model with defaults\n"
            "\n";

    WriteDefaultPars(out);

    WriteArgCheck(out);

    out <<
            "max_num_records = Inf;\n"
            "for i=1:num_fis\n"
            "    fi = fis(i);\n"
            "    if length(fi.Data) / fi.Sput < max_num_records\n"
            "        max_num_records = length(fi.Data) / fi.Sput;\n"
            "    end\n"
            "end\n"
            "if isempty(num_records)\n"
            "    num_records = max_num_records;\n"
            "elseif num_records > max_num_records;\n"
            "    error('Too many records requested');\n"
            "end\n"
            "\n";

    WriteDefsCall(out);

    out <<
            "num_inputs = " + num_model_pars + " + 2;\n"
            "if isempty(par_mat)\n"
            "    par_mat = [inputs{3:num_inputs}]';\n"
            "end\n"
            "\n"
            "num_tests = size(par_mat,1);\n";

    WriteChunkSize(out);

    out <<
            "if ~exist('k', 'var')\n"
            "    k = parallel.gpu.CUDAKernel(...\n"
            "       '" + NamePtx() + "', ...\n"
            "       '" + NameCu() + "'...\n"
            "     );\n"
            "    block_size_x = k.MaxThreadsPerBlock;\n"
            "    k.ThreadBlockSize = [block_size_x 1 1];\n"
            "    if chunk_size>block_size_x\n"
            "        bits = ceil(log2(chunk_size/block_size_x));\n"
            "        dimx_exp = max([ceil(bits/2) 1]);\n"
            "        dimy_exp = max([bits - dimx_exp 1]);\n"
            "        k.GridSize = [2^dimx_exp 2^dimy_exp 1];\n"
            "    else\n"
            "        k.GridSize = [1 1 1];\n"
            "    end\n"
            "end\n"
            "\n"
            "input_mat = zeros(num_inputs,num_tests);\n"
            "input_mat(1,:) = num_records*ones(1,num_tests);\n"
            "input_mat(2,:) = save_mod_n*ones(1,num_tests);\n"
            "num_pars = size(par_mat,2);\n"
            "input_mat(3:(2+num_pars),:) = par_mat';\n"
            "for i=2+num_pars+1 : num_inputs\n"
            "    input_mat(i,:) = inputs{i} * ones(1,num_tests);\n"
            "end\n"
            "\n";

    WriteCuCall(out);

    out <<
            "end\n";
}

std::string MRunCudaKernel::NameCu() const
{
    return NameExec() + ".cu";
}

std::string MRunCudaKernel::NamePtx() const
{
    return NameExec() + ".ptx";
}

void MRunCudaKernel::WriteArgCheck(std::ofstream& out) const
{
    const std::string num_inputs = std::to_string( _modelMgr->Model(ds::INP)->NumPars() ),
            num_input_files = std::to_string( static_cast<const VariableModel*>(
                _modelMgr->Model(ds::VAR))->TypeCount(Input::INPUT_FILE) );
    out <<
            "if ~isempty(par_mat) && size(par_mat,2)~=" + num_inputs + "\n"
            "    error('Incorrect number of parameters');\n"
            "end\n"
            "\n"
            "num_fis = length(fis);\n"
            "if num_fis~=" + num_input_files + "\n"
            "    error(['Incorrect number of inputs, " + num_input_files + " required, ' ... \n"
            "           num2str(num_fis) ' supplied.']);\n"
            "end\n"
            "\n";
}
void MRunCudaKernel::WriteChunkSize(std::ofstream& out) const
{
    out << "chunk_size = num_tests;\n";
}
void MRunCudaKernel::WriteCuCall(std::ofstream& out) const
{
    out <<
           "num_iters = round( num_records/model_step );\n"
           "num_outputs = length(output_names);\n"
           "out_mat = zeros((num_iters/save_mod_n)*num_outputs, num_tests);\n"
           "if isempty(fis)\n"
           "    input_data = [];\n"
           "    input_len = 0;\n"
           "else\n"
           "    input_data = zeros(length(fis(1).Data), num_fis);\n"
           "    input_len = length(fis(1).Data);\n"
           "end\n"
           "sput = zeros(num_fis,1);\n"
           "for i=1:num_fis\n"
           "    input_data(:,i) = fis(i).Data;\n"
           "    sput(i) = fis(i).Sput;\n"
           "end\n"
           "data = gather( feval(k, ...\n"
           "    input_data, input_len, sput, ...\n"
           "    input_mat, num_inputs, num_tests, out_mat) );\n"
           "if size(data,2)==1, data = reshape(data, size(data,1)/num_outputs, num_outputs); end\n"
           "\n";
}
void MRunCudaKernel::WriteDefsCall(std::ofstream& out) const
{
    std::string name_defs = ds::StripPath( NameDefs() );
    if (name_defs.find_last_of('.') != std::string::npos)
        name_defs.erase(name_defs.find_last_of('.'));
    out <<
           "xInfo = " + name_defs + ";\n"
           "inputs = xInfo.inputs;\n"
           "output_names = xInfo.output_names;\n"
           "model_step = xInfo.tau;\n"
           "\n";
}
void MRunCudaKernel::WriteDefaultPars(std::ofstream& out) const
{
    MRunBase::WriteDefaultPars(out);
    out <<
           "if nargin<3, par_mat = []; end\n"
           "if nargin<4, fis = []; end\n"
           "\n";
}
void MRunCudaKernel::WriteHeader(std::ofstream& out) const
{
    std::string name_run = ds::StripPath( NameRun() );
    name_run.erase(name_run.find_last_of('.'));
    out << "function [data, k] = " + name_run
           + "(num_records, save_mod_n, par_mat, fis, k)\n";
}
