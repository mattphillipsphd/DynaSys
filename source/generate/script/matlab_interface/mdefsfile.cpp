#include "mdefsfile.h"

MDefsFile::MDefsFile(const std::string& name) : MFileBase(name)
{
}

void MDefsFile::Make(std::ofstream& out) const
{
#ifdef DEBUG_FUNC
    ScopeTracker st("MDefsFile::Make", std::this_thread::get_id());
#endif
    const NumericModelBase
            * inputs = static_cast<const NumericModelBase*>(_modelMgr->Model(ds::INP)),
            * init_conds = static_cast<const NumericModelBase*>(_modelMgr->Model(ds::INIT)),
            * variables = static_cast<const NumericModelBase*>(_modelMgr->Model(ds::VAR)),
            * diffs = static_cast<const NumericModelBase*>(_modelMgr->Model(ds::DIFF));
    const size_t num_inputs = inputs->NumPars(),
            num_ics = init_conds->NumPars(),
            num_columns = num_inputs+num_ics,
            num_vars = variables->NumPars(),
            num_diffs = diffs->NumPars(),
            num_input_files = static_cast<const VariableModel*>(variables)
                                ->TypeCount(Input::INPUT_FILE);

    std::string name_m = ds::StripPath( NameDefs() );
    name_m.erase(name_m.find_last_of('.'));

    out <<
            "function [input_names, inputs, bounds, is_par, output_names, tau] = "
                + name_m + "()\n"
            "%Auto-generated by DynaSys version " + ds::VERSION_STR + "\n"
            "\n";

    //All the input parameter names
    const std::string num_all_inputs_str = std::to_string(NUM_AUTO_ARGS+num_columns+2*num_input_files);
    out <<
           "input_names = cell(" + num_all_inputs_str + ",1);\n"
           "input_names{1} = 'num_records';\n"
           "input_names{2} = 'save_mod_n';\n";
    size_t inn_ct = NUM_AUTO_ARGS+1;
    for (size_t i=0; i<num_inputs; ++i, ++inn_ct)
        out << "input_names{" + std::to_string(inn_ct) + "} = '" + inputs->Key(i) + "';\n";
    for (size_t i=0; i<num_ics; ++i, ++inn_ct)
        out << "input_names{" + std::to_string(inn_ct) + "} = '" + init_conds->ShortKey(i) + "0';\n";
    for (size_t i=0; i<num_vars; ++i)
        if (!variables->IsFreeze(i) && Input::Type(variables->Value(i))==Input::INPUT_FILE)
        {
            out << "input_names{" + std::to_string(inn_ct++) + "} = 'input_" + variables->Key(i) + "';\n";
            out << "input_names{" + std::to_string(inn_ct++) + "} = 'sput_" + variables->Key(i) + "';\n";
        }
    out << "\n";

    //All the inputs
    out << "inputs = cell(" + num_all_inputs_str + ",1);\n";
    size_t in_ct = NUM_AUTO_ARGS+1;
    for (size_t i=0; i<num_inputs; ++i, ++in_ct)
        out << "inputs{" + std::to_string(in_ct) + "} = " + inputs->Value(i)
                + ";\t%" + inputs->Key(i) + "\n";
    out << "\n";

        //Inportant to put the parameter names in the namespace because they can be
        //used as initial conditions
    out <<
            "for i=" + std::to_string(NUM_AUTO_ARGS+1)
                    + ":" + std::to_string(NUM_AUTO_ARGS+num_inputs) + "\n"
            "    eval([input_names{i} ' = ' num2str(inputs{i}) ';']);\n"
            "end\n"
            "\n";

    for (size_t i=0; i<num_ics; ++i, ++in_ct)
        out << "inputs{" + std::to_string(in_ct) + "} = " + init_conds->Value(i)
                + ";\t%" + init_conds->Key(i) + "\n";
    out << "\n";

    //The bounds on the inputs and possible initial conditions, relevant for optimization
    out << "bounds = NaN(" + num_all_inputs_str + ",2);\n";
    in_ct = NUM_AUTO_ARGS+1;
    for (size_t i=0; i<num_inputs; ++i, ++in_ct)
        out << "bounds(" + std::to_string(in_ct) + ",:) = ["
                + std::to_string(inputs->Minimum(i)) + " " + std::to_string(inputs->Maximum(i)) + "];\n";
    for (size_t i=0; i<num_ics; ++i, ++in_ct)
        out << "bounds(" + std::to_string(in_ct) + ",:) = ["
                + std::to_string(init_conds->Minimum(i)) + " " + std::to_string(init_conds->Maximum(i)) + "];\n";
    out << "\n";

    //A boolean vector describing which of the inputs are (potentially optimizable) parameters
    out <<
            "is_par = false(" + num_all_inputs_str + ", 1);\n"
            "is_par(" + std::to_string(NUM_AUTO_ARGS+1) + ":" + std::to_string(NUM_AUTO_ARGS+num_inputs)
                + ") = true;\n"
            "\n";

    //The column names for the output matrix
    out << "output_names = cell(" + std::to_string(num_vars+num_diffs) + ",1);\n";
    size_t out_ct = 1;
    for (size_t i=0; i<num_vars; ++i, ++out_ct)
        out << "output_names{" + std::to_string(out_ct) + "} = '" + variables->Key(i) + "';\n";
    for (size_t i=0; i<num_diffs; ++i, ++out_ct)
        out << "output_names{" + std::to_string(out_ct) + "} = '" + diffs->ShortKey(i) + "';\n";
    out << "\n";

    out << "tau = " + std::to_string(_modelMgr->ModelStep()) + ";\n\n";

    out << "end\n";
}

std::string MDefsFile::Name() const
{
    return NameDefs();
}
